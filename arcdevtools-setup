#!/usr/bin/env swift
//
// ARCDevTools Setup Script
// Version: 1.0.0
//
// Installs ARCDevTools configuration files, git hooks, and generates Makefile
// for ARC Labs Studio projects.
//

import Foundation

// MARK: - Constants

let version = "1.0.0"

// MARK: - Project Type Detection

enum ProjectType {
    case swiftPackage
    case iOSApp

    var displayName: String {
        switch self {
        case .swiftPackage: return "Swift Package"
        case .iOSApp: return "iOS App"
        }
    }
}

// MARK: - Command Line Arguments

struct Options {
    var withWorkflows: Bool = false
    var noWorkflows: Bool = false
    var showHelp: Bool = false

    var isInteractive: Bool {
        !withWorkflows && !noWorkflows
    }
}

func parseArguments() -> Options {
    var options = Options()
    let args = CommandLine.arguments.dropFirst()

    for arg in args {
        switch arg {
        case "--with-workflows":
            options.withWorkflows = true
        case "--no-workflows":
            options.noWorkflows = true
        case "--help", "-h":
            options.showHelp = true
        default:
            break
        }
    }

    return options
}

func printHelp() {
    print("")
    printInfo("üîß ARCDevTools Setup v\(version)")
    print("")
    print("Usage: arcdevtools-setup [options]")
    print("")
    print("Options:")
    print("  --with-workflows  Install GitHub Actions workflows (non-interactive)")
    print("  --no-workflows    Skip GitHub Actions workflows (non-interactive)")
    print("  --help, -h        Show this help message")
    print("")
    print("Examples:")
    print("  ./ARCDevTools/arcdevtools-setup                  # Interactive mode")
    print("  ./ARCDevTools/arcdevtools-setup --with-workflows # CI mode with workflows")
    print("  ./ARCDevTools/arcdevtools-setup --no-workflows   # CI mode without workflows")
    print("")
}

// MARK: - ANSI Colors

enum Color {
    static let red = "\u{001B}[0;31m"
    static let green = "\u{001B}[0;32m"
    static let yellow = "\u{001B}[1;33m"
    static let blue = "\u{001B}[0;34m"
    static let cyan = "\u{001B}[0;36m"
    static let reset = "\u{001B}[0m"
}

// MARK: - Utility Functions

func print(_ message: String, color: String) {
    print("\(color)\(message)\(Color.reset)")
}

func printInfo(_ message: String) {
    print(message, color: Color.cyan)
}

func printSuccess(_ message: String) {
    print("‚úì \(message)", color: Color.green)
}

func printError(_ message: String) {
    print("‚úó \(message)", color: Color.red)
}

func printWarning(_ message: String) {
    print("‚ö† \(message)", color: Color.yellow)
}

// MARK: - Path Resolution

let fileManager = FileManager.default
let scriptURL = URL(fileURLWithPath: CommandLine.arguments[0])
let scriptDir = scriptURL.deletingLastPathComponent()
let projectRoot = URL(fileURLWithPath: fileManager.currentDirectoryPath)

// MARK: - Setup Functions

func printBanner() {
    print("")
    printInfo("üîß ARCDevTools Setup v\(version)")
    print("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
    print("")
}

func detectProjectType() throws -> ProjectType {
    printInfo("üìÇ Detecting project type...")

    let hasPackageSwift = fileManager.fileExists(
        atPath: projectRoot.appendingPathComponent("Package.swift").path
    )

    let contents = (try? fileManager.contentsOfDirectory(atPath: projectRoot.path)) ?? []
    let hasXcodeProject = contents.contains { $0.hasSuffix(".xcodeproj") }

    // Also check subdirectories for xcodeproj (common pattern: AppName/AppName.xcodeproj)
    let hasNestedXcodeProject = contents.contains { item in
        let itemPath = projectRoot.appendingPathComponent(item)
        var isDir: ObjCBool = false
        guard fileManager.fileExists(atPath: itemPath.path, isDirectory: &isDir), isDir.boolValue else {
            return false
        }
        let subContents = (try? fileManager.contentsOfDirectory(atPath: itemPath.path)) ?? []
        return subContents.contains { $0.hasSuffix(".xcodeproj") }
    }

    let hasAnyXcodeProject = hasXcodeProject || hasNestedXcodeProject

    guard hasPackageSwift || hasAnyXcodeProject else {
        printError("No Package.swift or .xcodeproj detected")
        printError("Run this script from your project root directory")
        throw SetupError.invalidProjectRoot
    }

    // Swift Package takes priority (can have both Package.swift and xcodeproj)
    if hasPackageSwift {
        printSuccess("Swift Package detected")
        return .swiftPackage
    } else {
        printSuccess("iOS App detected (Xcode project)")
        return .iOSApp
    }
}

func findXcodeProjectPath() -> String? {
    // Check root directory
    let contents = (try? fileManager.contentsOfDirectory(atPath: projectRoot.path)) ?? []
    if let proj = contents.first(where: { $0.hasSuffix(".xcodeproj") }) {
        return proj
    }

    // Check subdirectories
    for item in contents {
        let itemPath = projectRoot.appendingPathComponent(item)
        var isDir: ObjCBool = false
        guard fileManager.fileExists(atPath: itemPath.path, isDirectory: &isDir), isDir.boolValue else {
            continue
        }
        let subContents = (try? fileManager.contentsOfDirectory(atPath: itemPath.path)) ?? []
        if let proj = subContents.first(where: { $0.hasSuffix(".xcodeproj") }) {
            return "\(item)/\(proj)"
        }
    }
    return nil
}

func detectXcodeScheme() -> String? {
    guard let projPath = findXcodeProjectPath() else { return nil }

    let fullPath = projectRoot.appendingPathComponent(projPath).path
    let task = Process()
    let pipe = Pipe()

    task.executableURL = URL(fileURLWithPath: "/usr/bin/xcodebuild")
    task.arguments = ["-list", "-project", fullPath]
    task.standardOutput = pipe
    task.standardError = FileHandle.nullDevice

    do {
        try task.run()
        task.waitUntilExit()

        let data = pipe.fileHandleForReading.readDataToEndOfFile()
        guard let output = String(data: data, encoding: .utf8) else { return nil }

        // Parse schemes from xcodebuild output
        let lines = output.components(separatedBy: "\n")
        var inSchemes = false
        for line in lines {
            if line.contains("Schemes:") {
                inSchemes = true
                continue
            }
            if inSchemes {
                let trimmed = line.trimmingCharacters(in: .whitespaces)
                if trimmed.isEmpty { break }
                return trimmed // Return first scheme
            }
        }
    } catch {
        // Silently fail, will return nil
    }

    return nil
}

func setupSwiftVersion() throws {
    print("")
    printInfo("üìã Creating .swift-version...")

    let swiftVersionDest = projectRoot.appendingPathComponent(".swift-version")

    // Default to Swift 6.0
    let swiftVersion = "6.0\n"

    try swiftVersion.write(to: swiftVersionDest, atomically: true, encoding: .utf8)
    printSuccess("   .swift-version (6.0)")
}

func setupConfigs() throws {
    print("")
    printInfo("üì¶ Copying configurations...")

    // SwiftLint
    let swiftlintSource = scriptDir.appendingPathComponent("configs/swiftlint.yml")
    if fileManager.fileExists(atPath: swiftlintSource.path) {
        let dest = projectRoot.appendingPathComponent(".swiftlint.yml")
        try? fileManager.removeItem(at: dest) // Remove if exists
        try fileManager.copyItem(at: swiftlintSource, to: dest)
        printSuccess("   .swiftlint.yml")
    } else {
        printWarning("   swiftlint.yml not found in ARCDevTools")
    }

    // SwiftFormat
    let swiftformatSource = scriptDir.appendingPathComponent("configs/swiftformat")
    if fileManager.fileExists(atPath: swiftformatSource.path) {
        let dest = projectRoot.appendingPathComponent(".swiftformat")
        try? fileManager.removeItem(at: dest) // Remove if exists
        try fileManager.copyItem(at: swiftformatSource, to: dest)
        printSuccess("   .swiftformat")
    } else {
        printWarning("   swiftformat not found in ARCDevTools")
    }
}

func setupGitHooks() throws {
    print("")
    printInfo("ü™ù Installing git hooks...")

    let gitDir = projectRoot.appendingPathComponent(".git")
    guard fileManager.fileExists(atPath: gitDir.path) else {
        printWarning("   .git not found (is this a git repository?)")
        return
    }

    let gitHooksDir = projectRoot.appendingPathComponent(".git/hooks")

    // Create hooks directory if it doesn't exist
    if !fileManager.fileExists(atPath: gitHooksDir.path) {
        try fileManager.createDirectory(at: gitHooksDir, withIntermediateDirectories: true)
        printSuccess("   Created .git/hooks directory")
    }

    // Pre-commit hook
    let preCommitSource = scriptDir.appendingPathComponent("hooks/pre-commit")
    if fileManager.fileExists(atPath: preCommitSource.path) {
        let preCommitDest = gitHooksDir.appendingPathComponent("pre-commit")
        try? fileManager.removeItem(at: preCommitDest)
        try fileManager.copyItem(at: preCommitSource, to: preCommitDest)
        try makeExecutable(preCommitDest)
        printSuccess("   pre-commit hook installed")
    }

    // Pre-push hook
    let prePushSource = scriptDir.appendingPathComponent("hooks/pre-push")
    if fileManager.fileExists(atPath: prePushSource.path) {
        let prePushDest = gitHooksDir.appendingPathComponent("pre-push")
        try? fileManager.removeItem(at: prePushDest)
        try fileManager.copyItem(at: prePushSource, to: prePushDest)
        try makeExecutable(prePushDest)
        printSuccess("   pre-push hook installed")
    }
}

func makeExecutable(_ url: URL) throws {
    let attributes = [FileAttributeKey.posixPermissions: 0o755]
    try fileManager.setAttributes(attributes, ofItemAtPath: url.path)
}

func generateMakefile(for projectType: ProjectType) throws {
    print("")
    printInfo("üìÑ Generating Makefile...")

    let makefileContent: String

    switch projectType {
    case .swiftPackage:
        makefileContent = """
# ARCDevTools Makefile (Swift Package)
# Auto-generated - Do not edit manually

.PHONY: help lint format fix build test setup hooks clean

help:
\t@echo "ARCDevTools - Available commands:"
\t@echo "  make lint      - Run SwiftLint"
\t@echo "  make format    - Run SwiftFormat (dry-run)"
\t@echo "  make fix       - Apply SwiftFormat"
\t@echo "  make build     - Build the package"
\t@echo "  make test      - Run tests"
\t@echo "  make setup     - Re-install hooks and configs"
\t@echo "  make hooks     - Re-install git hooks only"
\t@echo "  make clean     - Clean build artifacts"

lint:
\t@if command -v swiftlint >/dev/null 2>&1; then \\
\t\tswiftlint lint --config .swiftlint.yml; \\
\telse \\
\t\techo "‚ö†Ô∏è  SwiftLint not installed: brew install swiftlint"; \\
\tfi

format:
\t@if command -v swiftformat >/dev/null 2>&1; then \\
\t\tswiftformat --config .swiftformat --lint .; \\
\telse \\
\t\techo "‚ö†Ô∏è  SwiftFormat not installed: brew install swiftformat"; \\
\tfi

fix:
\t@if command -v swiftformat >/dev/null 2>&1; then \\
\t\tswiftformat --config .swiftformat .; \\
\telse \\
\t\techo "‚ö†Ô∏è  SwiftFormat not installed: brew install swiftformat"; \\
\tfi

build:
\t@swift build

test:
\t@swift test --parallel

setup:
\t@./ARCDevTools/arcdevtools-setup

hooks:
\t@./ARCDevTools/hooks/install-hooks.sh

clean:
\t@rm -rf .build DerivedData
\t@echo "‚úì Build artifacts removed"

"""

    case .iOSApp:
        // Detect scheme for iOS apps
        let scheme = detectXcodeScheme() ?? "$(SCHEME)"
        let schemeNote = detectXcodeScheme() == nil
            ? "# NOTE: Set SCHEME variable or run: make build SCHEME=YourScheme\nSCHEME ?= \n"
            : "SCHEME = \(scheme)\n"

        makefileContent = """
# ARCDevTools Makefile (iOS App)
# Auto-generated - Do not edit manually

\(schemeNote)
DESTINATION ?= platform=iOS Simulator,name=iPhone 16,OS=latest

.PHONY: help lint format fix build test setup hooks clean

help:
\t@echo "ARCDevTools - Available commands:"
\t@echo "  make lint      - Run SwiftLint"
\t@echo "  make format    - Run SwiftFormat (dry-run)"
\t@echo "  make fix       - Apply SwiftFormat"
\t@echo "  make build     - Build the iOS app"
\t@echo "  make test      - Run tests on iOS Simulator"
\t@echo "  make setup     - Re-install hooks and configs"
\t@echo "  make hooks     - Re-install git hooks only"
\t@echo "  make clean     - Clean build artifacts"

lint:
\t@if command -v swiftlint >/dev/null 2>&1; then \\
\t\tswiftlint lint --config .swiftlint.yml; \\
\telse \\
\t\techo "‚ö†Ô∏è  SwiftLint not installed: brew install swiftlint"; \\
\tfi

format:
\t@if command -v swiftformat >/dev/null 2>&1; then \\
\t\tswiftformat --config .swiftformat --lint .; \\
\telse \\
\t\techo "‚ö†Ô∏è  SwiftFormat not installed: brew install swiftformat"; \\
\tfi

fix:
\t@if command -v swiftformat >/dev/null 2>&1; then \\
\t\tswiftformat --config .swiftformat .; \\
\telse \\
\t\techo "‚ö†Ô∏è  SwiftFormat not installed: brew install swiftformat"; \\
\tfi

build:
\t@if [ -z "$(SCHEME)" ]; then \\
\t\techo "‚ö†Ô∏è  SCHEME not set. Run: make build SCHEME=YourScheme"; \\
\t\texit 1; \\
\tfi
\t@xcodebuild build \\
\t\t-scheme "$(SCHEME)" \\
\t\t-destination "$(DESTINATION)" \\
\t\t-configuration Debug \\
\t\tCODE_SIGN_IDENTITY="" \\
\t\tCODE_SIGNING_REQUIRED=NO \\
\t\tCODE_SIGNING_ALLOWED=NO

test:
\t@if [ -z "$(SCHEME)" ]; then \\
\t\techo "‚ö†Ô∏è  SCHEME not set. Run: make test SCHEME=YourScheme"; \\
\t\texit 1; \\
\tfi
\t@xcodebuild test \\
\t\t-scheme "$(SCHEME)" \\
\t\t-destination "$(DESTINATION)" \\
\t\t-configuration Debug \\
\t\tCODE_SIGN_IDENTITY="" \\
\t\tCODE_SIGNING_REQUIRED=NO \\
\t\tCODE_SIGNING_ALLOWED=NO

setup:
\t@./ARCDevTools/arcdevtools-setup

hooks:
\t@./ARCDevTools/hooks/install-hooks.sh

clean:
\t@rm -rf DerivedData
\t@xcodebuild clean -scheme "$(SCHEME)" 2>/dev/null || true
\t@echo "‚úì Build artifacts removed"

"""
    }

    let makefileDest = projectRoot.appendingPathComponent("Makefile")
    try makefileContent.write(to: makefileDest, atomically: true, encoding: .utf8)

    printSuccess("   Makefile generated (\(projectType.displayName))")
}

func setupWorkflows(for projectType: ProjectType) throws {
    print("")
    printInfo("‚öôÔ∏è  Copying GitHub Actions workflows (\(projectType.displayName))...")

    // Determine which workflow directory to use
    let workflowsDirName: String
    switch projectType {
    case .swiftPackage:
        workflowsDirName = "workflows-spm"
    case .iOSApp:
        workflowsDirName = "workflows-ios"
    }

    let workflowsSource = scriptDir.appendingPathComponent(workflowsDirName)
    let sharedWorkflowsSource = scriptDir.appendingPathComponent("workflows-spm")

    guard fileManager.fileExists(atPath: workflowsSource.path) else {
        printWarning("   \(workflowsDirName)/ not found in ARCDevTools")
        return
    }

    let githubWorkflowsDir = projectRoot.appendingPathComponent(".github/workflows")
    try? fileManager.createDirectory(at: githubWorkflowsDir, withIntermediateDirectories: true)

    // Workflows specific to project type (quality.yml, tests.yml)
    let projectSpecificWorkflows = ["quality.yml", "tests.yml"]

    // Copy project-specific workflows from the appropriate directory
    let workflowFiles = try fileManager.contentsOfDirectory(atPath: workflowsSource.path)
    for filename in workflowFiles where filename.hasSuffix(".yml") {
        let sourceFile = workflowsSource.appendingPathComponent(filename)
        let destFile = githubWorkflowsDir.appendingPathComponent(filename)

        let originalContent = try String(contentsOf: sourceFile, encoding: .utf8)

        let templateComment = """
        # ARCDevTools Workflow Template (\(projectType.displayName))
        # Source: https://github.com/arclabs-studio/ARCDevTools/\(workflowsDirName)/\(filename)
        #
        # This file was copied from ARCDevTools. You can customize it for your project.
        # To update: re-run ./ARCDevTools/arcdevtools-setup or manually copy from ARCDevTools/\(workflowsDirName)/

        """
        let newContent = templateComment + originalContent

        try? fileManager.removeItem(at: destFile)
        try newContent.write(to: destFile, atomically: true, encoding: .utf8)
        printSuccess("   \(filename)")
    }

    // Copy shared workflows from workflows-spm/ directory (those not project-specific)
    if fileManager.fileExists(atPath: sharedWorkflowsSource.path) {
        let sharedFiles = try fileManager.contentsOfDirectory(atPath: sharedWorkflowsSource.path)
        for filename in sharedFiles where filename.hasSuffix(".yml") && !projectSpecificWorkflows.contains(filename) {
            let sourceFile = sharedWorkflowsSource.appendingPathComponent(filename)
            let destFile = githubWorkflowsDir.appendingPathComponent(filename)

            // Skip if already exists (don't overwrite project-specific)
            if fileManager.fileExists(atPath: destFile.path) {
                continue
            }

            let originalContent = try String(contentsOf: sourceFile, encoding: .utf8)

            let templateComment = """
            # ARCDevTools Workflow Template
            # Source: https://github.com/arclabs-studio/ARCDevTools/workflows-spm/\(filename)
            #
            # This file was copied from ARCDevTools. You can customize it for your project.
            # To update: re-run ./ARCDevTools/arcdevtools-setup or manually copy from ARCDevTools/workflows-spm/

            """
            let newContent = templateComment + originalContent

            try? fileManager.removeItem(at: destFile)
            try newContent.write(to: destFile, atomically: true, encoding: .utf8)
            printSuccess("   \(filename)")
        }
    }

    // Copy templates
    let templatesDir = scriptDir.appendingPathComponent("templates")
    let githubDir = projectRoot.appendingPathComponent(".github")

    if fileManager.fileExists(atPath: templatesDir.path) {
        let templates = [
            "PULL_REQUEST_TEMPLATE.md",
            "markdown-link-check-config.json",
            "release-drafter.yml"
        ]

        for template in templates {
            let source = templatesDir.appendingPathComponent(template)
            let dest = githubDir.appendingPathComponent(template)

            if fileManager.fileExists(atPath: source.path) {
                try? fileManager.removeItem(at: dest)
                try? fileManager.copyItem(at: source, to: dest)
            }
        }
    }
}

func setupClaudeSkills() throws -> [String] {
    print("")
    printInfo("ü§ñ Installing Claude Code skills...")

    let skillsDir = projectRoot.appendingPathComponent(".claude/skills")

    // Create .claude/skills directory if it doesn't exist
    try? fileManager.createDirectory(at: skillsDir, withIntermediateDirectories: true)

    var installedSkills: [String] = []
    var symlinkedSkills: [String] = []

    // 1. Copy ARCDevTools-specific skills (like arc-package-validator)
    let arcDevToolsSkillsSource = scriptDir.appendingPathComponent(".claude/skills")
    if fileManager.fileExists(atPath: arcDevToolsSkillsSource.path) {
        let skills = try fileManager.contentsOfDirectory(atPath: arcDevToolsSkillsSource.path)
        for skillName in skills {
            let sourceSkill = arcDevToolsSkillsSource.appendingPathComponent(skillName)
            let destSkill = skillsDir.appendingPathComponent(skillName)

            // Check if it's a directory (a skill)
            var isDirectory: ObjCBool = false
            guard fileManager.fileExists(atPath: sourceSkill.path, isDirectory: &isDirectory),
                  isDirectory.boolValue else {
                continue
            }

            // Remove existing skill if present
            try? fileManager.removeItem(at: destSkill)

            // Copy skill directory recursively
            try fileManager.copyItem(at: sourceSkill, to: destSkill)

            // Make scripts executable
            let scriptsDir = destSkill.appendingPathComponent("scripts")
            if fileManager.fileExists(atPath: scriptsDir.path) {
                let scripts = try? fileManager.contentsOfDirectory(atPath: scriptsDir.path)
                for script in scripts ?? [] {
                    let scriptPath = scriptsDir.appendingPathComponent(script)
                    try? makeExecutable(scriptPath)
                }
            }

            installedSkills.append(skillName)
            printSuccess("   \(skillName) (copied)")
        }
    }

    // 2. Create symlinks for ARCKnowledge skills
    let arcKnowledgeSkillsSource = scriptDir.appendingPathComponent("ARCKnowledge/.claude/skills")
    if fileManager.fileExists(atPath: arcKnowledgeSkillsSource.path) {
        let skills = try fileManager.contentsOfDirectory(atPath: arcKnowledgeSkillsSource.path)
        for skillName in skills {
            let sourceSkill = arcKnowledgeSkillsSource.appendingPathComponent(skillName)
            let destSkill = skillsDir.appendingPathComponent(skillName)

            // Check if it's a directory (a skill)
            var isDirectory: ObjCBool = false
            guard fileManager.fileExists(atPath: sourceSkill.path, isDirectory: &isDirectory),
                  isDirectory.boolValue else {
                continue
            }

            // Skip if already exists (don't overwrite ARCDevTools skills)
            if fileManager.fileExists(atPath: destSkill.path) {
                continue
            }

            // Calculate relative path for symlink
            // From: .claude/skills/arc-workflow
            // To: ARCDevTools/ARCKnowledge/.claude/skills/arc-workflow
            let relativePath = calculateRelativePath(from: skillsDir, to: sourceSkill)

            // Create symlink
            try? fileManager.removeItem(at: destSkill)
            try fileManager.createSymbolicLink(atPath: destSkill.path, withDestinationPath: relativePath)

            installedSkills.append(skillName)
            symlinkedSkills.append(skillName)
            printSuccess("   \(skillName) (linked)")
        }
    }

    // 3. Update .gitignore with symlinked skills
    if !symlinkedSkills.isEmpty {
        try updateGitignoreWithSkills(symlinkedSkills)
    }

    if installedSkills.isEmpty {
        printWarning("   No skills found to install")
    }

    return installedSkills
}

func updateGitignoreWithSkills(_ skills: [String]) throws {
    let gitignorePath = projectRoot.appendingPathComponent(".gitignore")

    var gitignoreContent = ""
    if fileManager.fileExists(atPath: gitignorePath.path) {
        gitignoreContent = try String(contentsOf: gitignorePath, encoding: .utf8)
    }

    // Check if skills section already exists
    let skillsHeader = "# ARCKnowledge skills (symlinks)"
    if gitignoreContent.contains(skillsHeader) {
        // Already configured, skip
        return
    }

    // Build skills section
    var skillsSection = "\n\n\(skillsHeader)\n"
    for skill in skills.sorted() {
        skillsSection += ".claude/skills/\(skill)\n"
    }

    // Append to .gitignore
    gitignoreContent += skillsSection

    try gitignoreContent.write(to: gitignorePath, atomically: true, encoding: .utf8)
    printSuccess("   .gitignore updated with symlinked skills")
}

func calculateRelativePath(from source: URL, to target: URL) -> String {
    // Get the ARCDevTools directory name relative to project root
    let arcDevToolsName = scriptDir.lastPathComponent

    // The relative path from .claude/skills/ to ARCDevTools/ARCKnowledge/.claude/skills/skillName
    // is: ../../ARCDevTools/ARCKnowledge/.claude/skills/skillName
    let skillName = target.lastPathComponent
    return "../../\(arcDevToolsName)/ARCKnowledge/.claude/skills/\(skillName)"
}

func askUserForWorkflows() -> Bool {
    print("")
    print("Do you want to copy GitHub Actions workflows? [y/N]: ", terminator: "")

    guard let response = readLine()?.lowercased() else {
        return false
    }

    return response == "y" || response == "yes"
}

func printFinalSuccess(projectType: ProjectType, installedSkills: [String] = []) {
    print("")
    printSuccess("ARCDevTools v\(version) configured successfully")
    print("")
    print("üì¶ Project type: \(projectType.displayName)", color: Color.blue)
    print("")
    print("üìã Installed configurations:", color: Color.blue)
    print("   ‚Ä¢ .swift-version (v\(version))")
    print("   ‚Ä¢ .swiftlint.yml (v\(version))")
    print("   ‚Ä¢ .swiftformat (v\(version))")
    print("   ‚Ä¢ Makefile (v\(version))")
    print("")

    if !installedSkills.isEmpty {
        print("ü§ñ Claude Code skills installed:", color: Color.blue)
        for skill in installedSkills {
            print("   ‚Ä¢ \(skill)")
        }
        print("")
    }

    print("üìù Next steps:", color: Color.blue)
    print("   1. Run: make lint")
    print("   2. Run: make format")

    switch projectType {
    case .swiftPackage:
        print("   3. Run: make build")
        print("   4. Run: make test")
    case .iOSApp:
        print("   3. Run: make build SCHEME=YourScheme")
        print("   4. Run: make test SCHEME=YourScheme")
    }

    print("   5. Make a commit to test pre-commit hook")
    print("")
    print("üí° See available commands: make help", color: Color.blue)
    print("")
}

// MARK: - Error Handling

enum SetupError: Error {
    case invalidProjectRoot
}

// MARK: - Main Execution

func main() {
    let options = parseArguments()

    if options.showHelp {
        printHelp()
        return
    }

    do {
        printBanner()
        let projectType = try detectProjectType()
        try setupSwiftVersion()
        try setupConfigs()
        try setupGitHooks()
        try generateMakefile(for: projectType)

        // Handle workflows based on options
        let shouldInstallWorkflows: Bool
        if options.withWorkflows {
            shouldInstallWorkflows = true
        } else if options.noWorkflows {
            shouldInstallWorkflows = false
        } else {
            // Interactive mode
            shouldInstallWorkflows = askUserForWorkflows()
        }

        if shouldInstallWorkflows {
            try setupWorkflows(for: projectType)
        }

        // Install Claude Code skills
        let installedSkills = try setupClaudeSkills()

        printFinalSuccess(projectType: projectType, installedSkills: installedSkills)

    } catch {
        print("")
        printError("Error during setup: \(error)")
        exit(1)
    }
}

// Run
main()
